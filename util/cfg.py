#!/usr/bin/env python3 

# Consumes cfg.opts and generates cfg.c and cfg.h which provide a function for
# parsing a config file and populating a generated c struct. The generated code
# is sufficiently clean that it can then be tweaked by hand if necessary.

# cfg.opts should consist of lines of the following form:
#
# <option/field name> <type (must be string, int, or double)> <default val>

import sys
import re

h_template = '''//GENERATED BY %s.

#ifndef _CFG_H_
#define _CFG_H_

struct cfg {
{struct_fields}
};

struct cfg* parse_cfg(const char *fname);

#endif
''' % sys.argv[0]

c_template = r'''//GENERATED BY {script}

#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <stdlib.h>
#include "{header_file}"

static int kvp(char *line, char **key, char **val) {
  *key = NULL;
  *val = NULL;
  
  for(;*line != '\0';line++) {
    if(*line != ' ' && !*key)
      *key = line;
    
    if(*line == ':' && !*val) {
      *line++ = '\0';
      for(;isspace(*line);line++);
      *val = line;
    }
  }
  
  if(*(line - 1) == '\n')
    *(line - 1) = '\0';
  
  if(!(*val && *key))
    return -1;
  
  return 0;
}

struct cfg* parse_cfg(const char *fname) {
    char *line = NULL;
    size_t n = 0, ln = 0;
    struct cfg *cfg = malloc(sizeof(struct cfg));

{field_init}

    FILE *fp = fopen(fname, "r");
    if(!fp) return cfg; //Return defaults if no config file xists..
    while(getline(&line, &n, fp) != -1) {
        ln++;
        char *key, *val;
        if(kvp(line, &key, &val)) {
            fprintf(stderr, "Invalid entry in %s at line %lu.\n", fname, ln);
            exit(1);
        }

{field_checks}

        free(line);
        line = NULL;
        n = 0;
    }

    return cfg;
}
'''.replace('{script}', sys.argv[0])


conversion_map = {
        'string': 'strdup',
        'int': 'atoi',
        'double': 'atof',
}

def generate_h(options):
    struct_fields = '';
    for fld, typ, _ in options:
        struct_fields += '    %s %s;\n' % ('char*' if typ == 'string' else typ, fld)

    return h_template.replace('{struct_fields}', struct_fields.rstrip())

def generate_c(options, header_file):
    field_init = '';
    for fld, typ, default in options:
        field_init += '    cfg->%s = %s;\n' % (fld, '"%s"' % default
                if typ == 'string' else default)

    field_checks = '';

    cond = 'if'
    for i,t in enumerate(options):
        fld = t[0]
        typ = t[1]
        field_checks += '''\
        %s(!strcmp(key, "%s"))
            cfg->%s = %s(val);\n''' % (cond, fld, fld, conversion_map[typ])
        cond = 'else if'


    return c_template\
        .replace('{field_checks}', field_checks.rstrip())\
        .replace('{field_init}', field_init.rstrip())\
        .replace('{header_file}', header_file)

def read_opts(fname):
    ln = 0
    opts = []
    for l in open(fname, 'r').read().rstrip().split('\n'):
        ln+=1
        l = re.sub(' *//.*', '', l) #Strip comments
        opt = l.split(maxsplit=2)
        if len(opt) != 3 or not conversion_map.get(opt[1]):
            print("ERROR: line %d must be of format <field name> <type> <default value>" % ln)
            exit(1)

        opts.append(opt)

    return opts

opts = read_opts('cfg.opts');

header = generate_h(opts);
c = generate_c(opts, 'cfg.h');

open('cfg.c', 'w').write(c)
open('cfg.h', 'w').write(header)
print("Successfully generated cfg.h and cfg.c")

